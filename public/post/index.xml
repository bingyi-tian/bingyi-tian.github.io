<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on wood</title>
    <link>https://bingyi-tian.github.io/post/</link>
    <description>Recent content in Posts on wood</description>
    <image>
      <title>wood</title>
      <url>https://bingyi-tian.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://bingyi-tian.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.151.0</generator>
    <language>en</language>
    <lastBuildDate>Tue, 18 Nov 2025 18:52:32 +0800</lastBuildDate>
    <atom:link href="https://bingyi-tian.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Self_intersections</title>
      <link>https://bingyi-tian.github.io/post/self_intersections/</link>
      <pubDate>Tue, 18 Nov 2025 18:52:32 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/self_intersections/</guid>
      <description>&lt;p&gt;remove_self_intersections 和 autorefine_and_remove_self_intersections 是 CGAL 中用于处理多边形网格自相交问题的两个不同函数。虽然它们都有修复自相交网格的功能，但它们的具体操作和应用场景有所不同。&lt;/p&gt;
&lt;p&gt;remove_self_intersections： 检测并移除多边形网格中的自相交部分，再填补孔洞，得到的网格是分离的。&lt;/p&gt;
&lt;p&gt;autorefine_and_remove_self_intersections：不仅检测并移除自相交，还会自动进行网格细化，以提高网格质量，得到的网格是连接在一起的。&lt;/p&gt;
&lt;p&gt;1.自相交检测&lt;/p&gt;
&lt;p&gt;bool intersecting = CGAL::Polygon_mesh_processing::does_self_intersect(mesh);
AI写代码
cpp
运行
检测时间测试
文件大小	时间（秒）
25M	0.034
50M	0.05
100M	0.109
200M	0.2
400M	 0.408
1G	0.952
2.删除自相交&lt;/p&gt;
&lt;p&gt;CGAL::Polygon_mesh_processing::experimental::remove_self_intersections(mesh);
AI写代码
cpp
运行
效果测试：
&lt;img alt=&#34;image-20251118185315124&#34; loading=&#34;lazy&#34; src=&#34;e:\\Users\\Administrator\\Desktop\\blog\\bingyi-tian.github.io\\content\\post\\image\\image-20251118185315124.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间测试&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;文件大小&lt;/th&gt;
          &lt;th&gt;时间（秒）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;25M&lt;/td&gt;
          &lt;td&gt;1.838&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;50M&lt;/td&gt;
          &lt;td&gt;4.115&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;100M&lt;/td&gt;
          &lt;td&gt;10.787&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;200M&lt;/td&gt;
          &lt;td&gt;28.593&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;400M&lt;/td&gt;
          &lt;td&gt;68.749&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;1G&lt;/td&gt;
          &lt;td&gt;223.132&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3.删除自相交和网格重新细化&lt;/p&gt;
&lt;p&gt;CGAL::Polygon_mesh_processing::experimental::autorefine_and_remove_self_intersections(mesh);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效果测试：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;image-20251118185401340&#34; loading=&#34;lazy&#34; src=&#34;e:\\Users\\Administrator\\Desktop\\blog\\bingyi-tian.github.io\\content\\post\\image\\image-20251118185401340.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;时间测试 ：
提示“exception Non-handled triple intersection of input triangles”，未能得到修复时间&lt;/p&gt;
&lt;p&gt;测试电脑：
处理器    12th Gen Intel(R) Core(TM) i7-12700   2.10 GHz
RAM    32.0 GB&lt;/p&gt;</description>
    </item>
    <item>
      <title>Polygon_Mesh_Processing学习</title>
      <link>https://bingyi-tian.github.io/post/polygon_mesh_processing%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 16 Nov 2025 19:23:01 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/polygon_mesh_processing%E5%AD%A6%E4%B9%A0/</guid>
      <description></description>
    </item>
    <item>
      <title>Cgal配置教程</title>
      <link>https://bingyi-tian.github.io/post/cgal%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sun, 16 Nov 2025 15:01:36 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/cgal%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</guid>
      <description>&lt;p&gt;先安装ceres:&lt;/p&gt;
&lt;p&gt;基于官方文档，我为你推荐&lt;strong&gt;最简单实用的安装方案&lt;/strong&gt;：&lt;/p&gt;
&lt;h2 id=&#34;方案1使用vcpkg一键安装强烈推荐&#34;&gt;方案1：使用vcpkg一键安装（强烈推荐）&lt;/h2&gt;
&lt;p&gt;这是最省心的方法，适合99%的用户：&lt;/p&gt;
&lt;h3 id=&#34;步骤1安装vcpkg&#34;&gt;步骤1：安装vcpkg&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 在合适的位置（如D盘根目录）打开PowerShell
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
.\bootstrap-vcpkg.bat
.\vcpkg integrate install
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;步骤2安装ceres及所有依赖&#34;&gt;步骤2：安装Ceres及所有依赖&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 安装基础版本（推荐）
.\vcpkg.exe install ceres:x64-windows

# 或者安装包含SuiteSparse的完整版本
.\vcpkg.exe install ceres[suitesparse]:x64-windows
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;步骤3配置你的cgal项目&#34;&gt;步骤3：配置你的CGAL项目&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cd 你的项目目录
cmake -DCMAKE_BUILD_TYPE=Release ^
      -DCGAL_DIR=&amp;#34;D:\VisualStudio\Source\cgal\cgal\cgal&amp;#34; ^
      -DCMAKE_TOOLCHAIN_FILE=&amp;#34;D:\vcpkg\scripts\buildsystems\vcpkg.cmake&amp;#34; ^
      ../..
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;方案2手动编译仅限特殊情况&#34;&gt;方案2：手动编译（仅限特殊情况）&lt;/h2&gt;
&lt;p&gt;只有在需要特定版本或自定义配置时才用此方法：&lt;/p&gt;
&lt;h3 id=&#34;步骤1安装依赖&#34;&gt;步骤1：安装依赖&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 先用vcpkg安装依赖（这样最简单）
.\vcpkg.exe install eigen3 glog gflags:x64-windows
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;步骤2编译ceres&#34;&gt;步骤2：编译Ceres&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone https://github.com/ceres-solver/ceres-solver.git
cd ceres-solver
mkdir build
cd build

# 配置（替换为你的实际路径）
cmake .. ^
    -DCMAKE_INSTALL_PREFIX=&amp;#34;D:\Libraries\ceres&amp;#34; ^
    -DEigen3_DIR=&amp;#34;D:\vcpkg\installed\x64-windows\share\eigen3&amp;#34; ^
    -Dglog_DIR=&amp;#34;D:\vcpkg\installed\x64-windows\share\glog&amp;#34; ^
    -Dgflags_DIR=&amp;#34;D:\vcpkg\installed\x64-windows\share\gflags&amp;#34; ^
    -G &amp;#34;Visual Studio 17 2022&amp;#34; -A x64

cmake --build . --config Release
cmake --install . --config Release
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;验证安装&#34;&gt;验证安装&lt;/h2&gt;
&lt;p&gt;安装成功后，重新配置项目应该看到：&lt;/p&gt;</description>
    </item>
    <item>
      <title>运行自适应包面算法注意事项</title>
      <link>https://bingyi-tian.github.io/post/%E8%BF%90%E8%A1%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%8C%85%E9%9D%A2%E7%AE%97%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Sat, 25 Oct 2025 18:28:28 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/%E8%BF%90%E8%A1%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%8C%85%E9%9D%A2%E7%AE%97%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>&lt;p&gt;目前算法只支持obj模型&lt;/p&gt;</description>
    </item>
    <item>
      <title>自适应alpha的alphawrap参数有哪些</title>
      <link>https://bingyi-tian.github.io/post/%E8%87%AA%E9%80%82%E5%BA%94alpha%E7%9A%84alphawrap%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Sat, 25 Oct 2025 16:19:06 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/%E8%87%AA%E9%80%82%E5%BA%94alpha%E7%9A%84alphawrap%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description>&lt;p&gt;注意很多模型有重复点，要先把重复点消除掉，可以用meshlab&lt;/p&gt;
&lt;p&gt;首先，代码的核心创新点，alpha的特征自适应，是通过feature_coff控制的，具体实现如下（在geometry_utils.h中）：
简洁版本：
// 特征边处理 - 更高密度采样
if (是特征边) {
mean_sizing /= (基础系数 * 特征系数);
} else {
mean_sizing /= 基础系数;
}
原版本：
// 特征边处理
// find feature edge
// e_feature_ 是一个标记数组（如Eigen矩阵或二维数组），存储每条边是否为特征边
if (m_oracle.e_feature_(face_id * 3, 0) == 1 || m_oracle.e_feature_(face_id * 3 + 1, 0) == 1 || m_oracle.e_feature_(face_id * 3 + 2, 0) == 1) {
// coff_是全局缩放系数，控制整体网格密度。
// feature_coff_是特征边的缩放系数，控制特征边的局部密度。
mean_sizing /= (m_oracle.coff_ * m_oracle.feature_coff_);
}
else {
mean_sizing /= m_oracle.coff_;
}&lt;/p&gt;</description>
    </item>
    <item>
      <title>Run_alpha_wrap3</title>
      <link>https://bingyi-tian.github.io/post/run_alpha_wrap3/</link>
      <pubDate>Sat, 25 Oct 2025 15:45:03 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/run_alpha_wrap3/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone https://github.com/CGAL/cgal.git


PS D:\VisualStudio\Source\cgal\cgal\cgal\Alpha_wrap_3\examples\Alpha_wrap_3&amp;gt; ls


    目录: D:\VisualStudio\Source\cgal\cgal\cgal\Alpha_wrap_3\examples\Alpha_wrap_3


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        2025/10/25     15:28            738 CMakeLists.txt
-a----        2025/10/25     15:28           4967 mixed_inputs_wrap.cpp
-a----        2025/10/25     15:28            748 output_helper.h
-a----        2025/10/25     15:28           6346 pause_and_resume_wrapping.cpp
-a----        2025/10/25     15:28           2283 point_set_wrap.cpp
-a----        2025/10/25     15:28           5370 successive_wraps.cpp
-a----        2025/10/25     15:28           2386 triangle_mesh_wrap.cpp
-a----        2025/10/25     15:28           2415 triangle_soup_wrap.cpp
-a----        2025/10/25     15:28           6545 volumetric_wrap.cpp
-a----        2025/10/25     15:28           3093 wrap_from_cavity.cpp

mkdir -p build/debug

cmake -DCMAKE_BUILD_TYPE=Debug -DCGAL_DIR=&amp;#34;D:/VisualStudio/Source/cgal/cgal/cgal&amp;#34; ../..
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Cgal中kernel Predicate Oracle都是什么鬼</title>
      <link>https://bingyi-tian.github.io/post/cgal%E4%B8%ADkernel-predicate-oracle%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/</link>
      <pubDate>Tue, 23 Sep 2025 14:44:18 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/cgal%E4%B8%ADkernel-predicate-oracle%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/</guid>
      <description>学习一下这几个都是什么</description>
    </item>
    <item>
      <title>Alpha Wrap</title>
      <link>https://bingyi-tian.github.io/post/alpha-wrap/</link>
      <pubDate>Tue, 23 Sep 2025 13:38:43 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/alpha-wrap/</guid>
      <description>&lt;h1 id=&#34;算法分为refinement细化和carving雕刻&#34;&gt;算法分为Refinement细化和Carving雕刻&lt;/h1&gt;
&lt;h2 id=&#34;检查门&#34;&gt;检查门&lt;/h2&gt;
&lt;p&gt;如果门不可被alpha球穿过，证明这个门已经达到目标尺寸了，所以就停止收缩了，就跳过他&lt;/p&gt;
&lt;h2 id=&#34;规则r1-refinement---voronoi边相交-&#34;&gt;规则R1（ Refinement - Voronoi边相交 ）&lt;/h2&gt;
&lt;p&gt;计算门f的对偶边，也就是链接这个门两边的四面体，如果这个连接线与偏移曲面相交，则触发规则R1：&lt;/p&gt;
&lt;p&gt;将从outside指向inside方向的第一个交点作为Steiner点插入到Delaunay三角剖分中。&lt;/p&gt;
&lt;h2 id=&#34;规则r2refinement---防止暴露输入&#34;&gt;规则R2（Refinement - 防止暴露输入）&lt;/h2&gt;
&lt;p&gt;若两个相邻单元的外接球中心相连组成的线段，与偏移曲面不相交，但是inside这个四面体与输入几何体相交，如果对他进行雕刻的话，就暴露了，所以自然而然的出现！规则2：把这个与输入几何体相交的四面体的外接球球心搞出来，然后往几何体上投影，这个投影就是steiner点。&lt;/p&gt;
&lt;h2 id=&#34;雕刻&#34;&gt;雕刻&lt;/h2&gt;
&lt;p&gt;如果没有触发这些规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;门大于alpha球&lt;/li&gt;
&lt;li&gt;inside这个四面体不与输入几何相交，即同时不满足上面的两个Rule
&lt;ol&gt;
&lt;li&gt;门的对偶边，outside四面体和inside四面体的外接球心连线不会与偏移曲面相交&lt;/li&gt;
&lt;li&gt;inside 不予输入几何相交&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就执行雕刻，雕刻这个词有点装逼，其实就是把inside这个单元标记为outside，然后检查这个outside四面体，把其中新生成的三个面中，满足面的大小大于alpha的面加入门的优先级队列。&lt;/p&gt;
&lt;h2 id=&#34;终止条件&#34;&gt;终止条件&lt;/h2&gt;
&lt;p&gt;首先明确一个数值Φ(f)，Φ(f)就是面f的最小Delaunay球半径？？？？还是外接圆？？？&lt;/p&gt;
&lt;p&gt;也就是说是这个面最小空球半径&lt;/p&gt;
&lt;p&gt;面的 &lt;strong&gt;Φ(f)&lt;/strong&gt; 必然递减，每次插入Steiner点时，新生成的面的Φ(f)&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;放了个国庆，要收收心了。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
