<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on wood</title>
    <link>https://bingyi-tian.github.io/post/</link>
    <description>Recent content in Posts on wood</description>
    <image>
      <title>wood</title>
      <url>https://bingyi-tian.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://bingyi-tian.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.151.0</generator>
    <language>en</language>
    <lastBuildDate>Sat, 25 Oct 2025 18:28:28 +0800</lastBuildDate>
    <atom:link href="https://bingyi-tian.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>运行自适应包面算法注意事项</title>
      <link>https://bingyi-tian.github.io/post/%E8%BF%90%E8%A1%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%8C%85%E9%9D%A2%E7%AE%97%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Sat, 25 Oct 2025 18:28:28 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/%E8%BF%90%E8%A1%8C%E8%87%AA%E9%80%82%E5%BA%94%E5%8C%85%E9%9D%A2%E7%AE%97%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>&lt;p&gt;目前算法只支持obj模型&lt;/p&gt;</description>
    </item>
    <item>
      <title>自适应alpha的alphawrap参数有哪些</title>
      <link>https://bingyi-tian.github.io/post/%E8%87%AA%E9%80%82%E5%BA%94alpha%E7%9A%84alphawrap%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Sat, 25 Oct 2025 16:19:06 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/%E8%87%AA%E9%80%82%E5%BA%94alpha%E7%9A%84alphawrap%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description>&lt;p&gt;注意很多模型有重复点，要先把重复点消除掉，可以用meshlab&lt;/p&gt;
&lt;p&gt;首先，代码的核心创新点，alpha的特征自适应，是通过feature_coff控制的，具体实现如下（在geometry_utils.h中）：
简洁版本：
// 特征边处理 - 更高密度采样
if (是特征边) {
mean_sizing /= (基础系数 * 特征系数);
} else {
mean_sizing /= 基础系数;
}
原版本：
// 特征边处理
// find feature edge
// e_feature_ 是一个标记数组（如Eigen矩阵或二维数组），存储每条边是否为特征边
if (m_oracle.e_feature_(face_id * 3, 0) == 1 || m_oracle.e_feature_(face_id * 3 + 1, 0) == 1 || m_oracle.e_feature_(face_id * 3 + 2, 0) == 1) {
// coff_是全局缩放系数，控制整体网格密度。
// feature_coff_是特征边的缩放系数，控制特征边的局部密度。
mean_sizing /= (m_oracle.coff_ * m_oracle.feature_coff_);
}
else {
mean_sizing /= m_oracle.coff_;
}&lt;/p&gt;</description>
    </item>
    <item>
      <title>Run_alpha_wrap3</title>
      <link>https://bingyi-tian.github.io/post/run_alpha_wrap3/</link>
      <pubDate>Sat, 25 Oct 2025 15:45:03 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/run_alpha_wrap3/</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone https://github.com/CGAL/cgal.git


PS D:\VisualStudio\Source\cgal\cgal\cgal\Alpha_wrap_3\examples\Alpha_wrap_3&amp;gt; ls


    目录: D:\VisualStudio\Source\cgal\cgal\cgal\Alpha_wrap_3\examples\Alpha_wrap_3


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        2025/10/25     15:28            738 CMakeLists.txt
-a----        2025/10/25     15:28           4967 mixed_inputs_wrap.cpp
-a----        2025/10/25     15:28            748 output_helper.h
-a----        2025/10/25     15:28           6346 pause_and_resume_wrapping.cpp
-a----        2025/10/25     15:28           2283 point_set_wrap.cpp
-a----        2025/10/25     15:28           5370 successive_wraps.cpp
-a----        2025/10/25     15:28           2386 triangle_mesh_wrap.cpp
-a----        2025/10/25     15:28           2415 triangle_soup_wrap.cpp
-a----        2025/10/25     15:28           6545 volumetric_wrap.cpp
-a----        2025/10/25     15:28           3093 wrap_from_cavity.cpp

mkdir -p build/debug

cmake -DCMAKE_BUILD_TYPE=Debug -DCGAL_DIR=&amp;#34;D:/VisualStudio/Source/cgal/cgal/cgal&amp;#34; ../..
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Cgal中kernel Predicate Oracle都是什么鬼</title>
      <link>https://bingyi-tian.github.io/post/cgal%E4%B8%ADkernel-predicate-oracle%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/</link>
      <pubDate>Tue, 23 Sep 2025 14:44:18 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/cgal%E4%B8%ADkernel-predicate-oracle%E9%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/</guid>
      <description>学习一下这几个都是什么</description>
    </item>
    <item>
      <title>Alpha Wrap</title>
      <link>https://bingyi-tian.github.io/post/alpha-wrap/</link>
      <pubDate>Tue, 23 Sep 2025 13:38:43 +0800</pubDate>
      <guid>https://bingyi-tian.github.io/post/alpha-wrap/</guid>
      <description>&lt;h1 id=&#34;算法分为refinement细化和carving雕刻&#34;&gt;算法分为Refinement细化和Carving雕刻&lt;/h1&gt;
&lt;h2 id=&#34;检查门&#34;&gt;检查门&lt;/h2&gt;
&lt;p&gt;如果门不可被alpha球穿过，证明这个门已经达到目标尺寸了，所以就停止收缩了，就跳过他&lt;/p&gt;
&lt;h2 id=&#34;规则r1-refinement---voronoi边相交-&#34;&gt;规则R1（ Refinement - Voronoi边相交 ）&lt;/h2&gt;
&lt;p&gt;计算门f的对偶边，也就是链接这个门两边的四面体，如果这个连接线与偏移曲面相交，则触发规则R1：&lt;/p&gt;
&lt;p&gt;将从outside指向inside方向的第一个交点作为Steiner点插入到Delaunay三角剖分中。&lt;/p&gt;
&lt;h2 id=&#34;规则r2refinement---防止暴露输入&#34;&gt;规则R2（Refinement - 防止暴露输入）&lt;/h2&gt;
&lt;p&gt;若两个相邻单元的外接球中心相连组成的线段，与偏移曲面不相交，但是inside这个四面体与输入几何体相交，如果对他进行雕刻的话，就暴露了，所以自然而然的出现！规则2：把这个与输入几何体相交的四面体的外接球球心搞出来，然后往几何体上投影，这个投影就是steiner点。&lt;/p&gt;
&lt;h2 id=&#34;雕刻&#34;&gt;雕刻&lt;/h2&gt;
&lt;p&gt;如果没有触发这些规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;门大于alpha球&lt;/li&gt;
&lt;li&gt;inside这个四面体不与输入几何相交，即同时不满足上面的两个Rule
&lt;ol&gt;
&lt;li&gt;门的对偶边，outside四面体和inside四面体的外接球心连线不会与偏移曲面相交&lt;/li&gt;
&lt;li&gt;inside 不予输入几何相交&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就执行雕刻，雕刻这个词有点装逼，其实就是把inside这个单元标记为outside，然后检查这个outside四面体，把其中新生成的三个面中，满足面的大小大于alpha的面加入门的优先级队列。&lt;/p&gt;
&lt;h2 id=&#34;终止条件&#34;&gt;终止条件&lt;/h2&gt;
&lt;p&gt;首先明确一个数值Φ(f)，Φ(f)就是面f的最小Delaunay球半径？？？？还是外接圆？？？&lt;/p&gt;
&lt;p&gt;也就是说是这个面最小空球半径&lt;/p&gt;
&lt;p&gt;面的 &lt;strong&gt;Φ(f)&lt;/strong&gt; 必然递减，每次插入Steiner点时，新生成的面的Φ(f)&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;放了个国庆，要收收心了。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
